# ğŸ¯ Reglas de Cursor AI para Gael GarcÃ­a Portfolio

## ğŸ“‹ INSTRUCCIONES GENERALES

Estas reglas DEBEN ser leÃ­das y seguidas ANTES de ejecutar cualquier prompt o tarea en este proyecto.

---

## ğŸ—ï¸ ARQUITECTURA DEL PROYECTO

### PatrÃ³n Atomic Design

Este proyecto sigue ESTRICTAMENTE el patrÃ³n Atomic Design:

```
Atoms â†’ Molecules â†’ Organisms â†’ Templates â†’ Pages
```

**NUNCA:**

- Mezclar niveles jerÃ¡rquicos incorrectamente
- Crear un componente en el nivel incorrecto
- Importar un nivel superior en un nivel inferior (ej: Organism en Atom)

**SIEMPRE:**

- Atoms solo contienen componentes UI bÃ¡sicos sin dependencias
- Molecules combinan Atoms
- Organisms combinan Molecules y Atoms
- Templates definen layouts sin contenido especÃ­fico
- Pages son instancias de Templates con contenido real

---

## ğŸ“ ESTRUCTURA DE ARCHIVOS

### OrganizaciÃ³n de Componentes

Cada componente DEBE seguir esta estructura EXACTA:

```
ComponentName/
â”œâ”€â”€ ComponentName.tsx    (PascalCase, mismo nombre que la carpeta)
â””â”€â”€ index.ts            (export default Ãºnicamente)
```

**PROHIBIDO:**

- Crear mÃºltiples componentes en un solo archivo
- Usar nombres diferentes entre carpeta y archivo
- Exportar mÃºltiples componentes desde index.ts
- Crear archivos de estilos CSS separados (usar Tailwind)

---

## ğŸ’» CONVENCIONES DE CÃ“DIGO

### 1. Nomenclatura

**Componentes (Archivos .tsx):**

- SIEMPRE PascalCase: `Button.tsx`, `FormField.tsx`, `ProjectCard.tsx`
- El nombre del archivo DEBE coincidir con el nombre del componente
- El nombre de la carpeta DEBE coincidir con el nombre del componente

**Hooks:**

- SIEMPRE prefijo `use` + camelCase: `useWindowSize.ts`, `useAuth.ts`
- Un hook por archivo

**Utilidades:**

- SIEMPRE camelCase: `formatters.ts`, `validators.ts`
- Agrupar funciones relacionadas

**Tipos:**

- SIEMPRE PascalCase con sufijo `.types.ts`: `common.types.ts`, `user.types.ts`

### 2. Imports

**OBLIGATORIO usar alias de importaciÃ³n:**

```typescript
// âœ… CORRECTO
import Button from "@atoms/Button";
import FormField from "@molecules/FormField";
import Navbar from "@organisms/Navbar";
import MainLayout from "@templates/MainLayout";
import Home from "@pages/Home";
import { useWindowSize } from "@hooks/useWindowSize";
import { formatDate } from "@utils/formatters";
import type { Project } from "@types/common.types";

// âŒ INCORRECTO
import Button from "../../components/atoms/Button";
import FormField from "../molecules/FormField";
```

**Orden de imports (SIEMPRE en este orden):**

1. React y librerÃ­as externas
2. Componentes (atoms â†’ molecules â†’ organisms â†’ templates â†’ pages)
3. Hooks
4. Utils
5. Types
6. Estilos/Assets

### 3. Sintaxis TypeScript

**SIEMPRE:**

- Usar TypeScript strict mode
- Definir interfaces para props: `ComponentNameProps`
- Tipar todas las funciones, variables y parÃ¡metros
- Usar `React.FC<PropsType>` para componentes funcionales
- Preferir `interface` sobre `type` para objetos
- Usar `type` para unions, intersections y primitivas

**Ejemplo de componente correcto:**

```typescript
import React from "react";

interface ButtonProps {
  children: React.ReactNode;
  variant?: "primary" | "secondary" | "outline";
  size?: "sm" | "md" | "lg";
  onClick?: () => void;
  disabled?: boolean;
  className?: string;
}

const Button: React.FC<ButtonProps> = ({
  children,
  variant = "primary",
  size = "md",
  onClick,
  disabled = false,
  className = "",
}) => {
  // lÃ³gica del componente

  return <button>{children}</button>;
};

export default Button;
```

### 4. Estilos

**SIEMPRE usar Tailwind CSS:**

- NO crear archivos CSS separados para componentes
- Usar clases de Tailwind directamente en JSX
- Para estilos dinÃ¡micos, usar template literals
- Mantener consistencia con las variables CSS en `src/style.css`

**PROHIBIDO:**

- Inline styles con el atributo `style`
- Importar archivos CSS en componentes (excepto main.tsx)
- Usar CSS modules

### 5. Formato de CÃ³digo

**Prettier/Formatter configuraciÃ³n:**

- Comillas dobles `"` para strings (NO comillas simples)
- Punto y coma `;` al final de statements
- Trailing commas en objetos y arrays
- 2 espacios de indentaciÃ³n
- Max line length: 80-100 caracteres
- Arrow functions con parÃ©ntesis: `(x) => x`

---

## ğŸš« PROHIBICIONES ESTRICTAS

### NUNCA hacer lo siguiente:

1. **Duplicar cÃ³digo:**

   - Si un cÃ³digo se repite 2+ veces, crear un componente/funciÃ³n reutilizable
   - Revisar si ya existe un componente similar antes de crear uno nuevo

2. **Modificar archivos de configuraciÃ³n sin razÃ³n:**
   - `tsconfig.json`
   - `vite.config.ts`
   - `package.json` (scripts)
3. **Crear componentes fuera de la estructura Atomic Design:**

   - TODO componente debe estar en atoms/molecules/organisms/templates/pages
   - NO crear carpeta "components/common" o similar

4. **Ignorar TypeScript errors:**

   - TODO cÃ³digo debe compilar sin errores de TypeScript
   - NO usar `@ts-ignore` o `any` sin justificaciÃ³n

5. **Desestructurar incorrectamente:**

   - Siempre desestructurar props en la firma de la funciÃ³n
   - NO acceder a props con `props.nombreProp` dentro del componente

6. **Crear archivos innecesarios:**
   - NO crear archivos de test (a menos que se solicite explÃ­citamente)
   - NO crear archivos de configuraciÃ³n adicionales
   - NO crear archivos .spec.ts o .test.ts automÃ¡ticamente

---

## âœ… MEJORES PRÃCTICAS OBLIGATORIAS

### 1. Componentes

**Cada componente DEBE:**

- Tener una sola responsabilidad (Single Responsibility Principle)
- Ser reutilizable cuando sea posible
- Tener props bien tipadas con TypeScript
- Incluir valores por defecto para props opcionales
- Usar destructuring en la firma de la funciÃ³n

**TamaÃ±o de componentes:**

- Atoms: 20-50 lÃ­neas mÃ¡ximo
- Molecules: 50-100 lÃ­neas mÃ¡ximo
- Organisms: 100-200 lÃ­neas mÃ¡ximo
- Si excede estos lÃ­mites, considerar dividir el componente

### 2. Estado y Props

**Props:**

- SIEMPRE tipar con interface `ComponentNameProps`
- Colocar la interface ANTES del componente
- Usar `?` para props opcionales
- Documentar props complejas con JSDoc comments

**Estado:**

- Usar `useState` para estado local simple
- Colocar `useState` al inicio del componente
- Nombrar estado con pares: `[value, setValue]` o `[isOpen, setIsOpen]`

### 3. Funciones y Eventos

**Handlers de eventos:**

- Nombrar con prefijo `handle`: `handleClick`, `handleSubmit`, `handleChange`
- Colocar handlers ANTES del return
- Tipar parÃ¡metros de eventos: `React.MouseEvent`, `React.ChangeEvent<HTMLInputElement>`

**Funciones auxiliares:**

- Colocar DENTRO del componente si usan props/state
- Colocar en `/utils` si son puras y reutilizables

### 4. Comentarios

**SIEMPRE comentar:**

- LÃ³gica compleja que no es obvia
- Funciones de utilidad con JSDoc
- Tipos complejos con descripciÃ³n

**NUNCA comentar:**

- CÃ³digo obvio
- CÃ³digo que se explica por sÃ­ mismo
- TODO lo que sea autoexplicativo

### 5. Performance

**SIEMPRE:**

- Usar `React.memo` para componentes que se renderizan frecuentemente
- Usar `useCallback` para funciones pasadas como props
- Usar `useMemo` para cÃ¡lculos costosos
- Evitar crear funciones/objetos dentro del JSX

---

## ğŸ“ PROCESO ANTES DE CREAR/MODIFICAR CÃ“DIGO

### Checklist OBLIGATORIO antes de crear un componente:

1. âœ… Â¿Ya existe un componente similar?
2. âœ… Â¿CuÃ¡l es el nivel correcto en Atomic Design?
3. âœ… Â¿El nombre sigue la convenciÃ³n PascalCase?
4. âœ… Â¿Las props estÃ¡n correctamente tipadas?
5. âœ… Â¿Usa los alias de importaciÃ³n?
6. âœ… Â¿Sigue el formato de carpeta/archivo establecido?
7. âœ… Â¿El cÃ³digo estÃ¡ formateado correctamente?
8. âœ… Â¿No hay duplicaciÃ³n de cÃ³digo?

### Checklist OBLIGATORIO antes de modificar cÃ³digo existente:

1. âœ… Â¿He leÃ­do el cÃ³digo existente completo?
2. âœ… Â¿Entiendo la estructura actual?
3. âœ… Â¿Mi cambio respeta la arquitectura?
4. âœ… Â¿No rompo funcionalidad existente?
5. âœ… Â¿Mantengo el estilo de cÃ³digo consistente?
6. âœ… Â¿No introduzco duplicaciÃ³n?

---

## ğŸ”„ FLUJO DE TRABAJO

### Al recibir una solicitud de nuevo componente:

1. **Identificar el nivel de Atomic Design**

   - Â¿Es un elemento UI bÃ¡sico? â†’ Atom
   - Â¿Combina 2-3 Ã¡tomos? â†’ Molecule
   - Â¿Es una secciÃ³n completa? â†’ Organism
   - Â¿Es un layout? â†’ Template
   - Â¿Es una pÃ¡gina con contenido? â†’ Page

2. **Verificar componentes existentes**

   - Buscar en la carpeta correspondiente
   - Revisar si se puede reutilizar o extender uno existente

3. **Crear estructura de archivos**

   - Crear carpeta con nombre del componente
   - Crear ComponentName.tsx
   - Crear index.ts

4. **Implementar el componente**

   - Definir interface de props
   - Implementar componente funcional
   - AÃ±adir estilos con Tailwind
   - Export default

5. **Verificar**
   - CompilaciÃ³n sin errores
   - Formato de cÃ³digo correcto
   - Imports usando alias
   - Sin cÃ³digo duplicado

### Al recibir una solicitud de modificaciÃ³n:

1. **Leer el archivo completo**
2. **Entender el contexto y dependencias**
3. **Hacer cambios mÃ­nimos necesarios**
4. **Mantener el estilo existente**
5. **Verificar que no se rompe nada**

---

## ğŸ¨ ESTILOS CON TAILWIND

### Reglas para usar Tailwind:

**SIEMPRE:**

- Usar utility classes de Tailwind
- Agrupar clases relacionadas: layout â†’ spacing â†’ sizing â†’ colors â†’ effects
- Usar variables CSS de `src/style.css` cuando sea apropiado
- Mantener consistencia de colores:
  - Primary: `blue-600`
  - Secondary: `purple-600`
  - Accent: `amber-500`
  - Gray: `gray-*`

**Template para clases dinÃ¡micas:**

```typescript
const baseStyles = "clase1 clase2 clase3";
const variantStyles = {
  primary: "bg-blue-600 text-white",
  secondary: "bg-purple-600 text-white",
};

<div className={`${baseStyles} ${variantStyles[variant]}`}>
```

---

## ğŸ“¦ GESTIÃ“N DE DEPENDENCIAS

### Antes de instalar una dependencia:

1. âœ… Â¿Es realmente necesaria?
2. âœ… Â¿No se puede implementar con las herramientas existentes?
3. âœ… Â¿EstÃ¡ bien mantenida? (Ãºltima actualizaciÃ³n < 6 meses)
4. âœ… Â¿No tiene vulnerabilidades conocidas?
5. âœ… Â¿Es la mÃ¡s ligera disponible?

### PROHIBIDO instalar:

- LibrerÃ­as de UI completas (Material-UI, Ant Design, etc.) - Ya tenemos Tailwind
- jQuery o similares - Usamos React
- LibrerÃ­as obsoletas o sin mantenimiento
- MÃºltiples librerÃ­as que hacen lo mismo

---

## ğŸ› MANEJO DE ERRORES

### SIEMPRE:

- Validar inputs de usuario
- Manejar casos edge (null, undefined, arrays vacÃ­os)
- Proporcionar feedback visual apropiado
- Usar try-catch para operaciones asÃ­ncronas

### NUNCA:

- Dejar errores sin manejar
- Usar `console.log` en producciÃ³n (usar solo para debug temporal)
- Mostrar errores tÃ©cnicos al usuario
- Ignorar warnings de TypeScript

---

## ğŸ“š DOCUMENTACIÃ“N

### CuÃ¡ndo actualizar documentaciÃ³n:

**SIEMPRE actualizar cuando:**

- Creas un nuevo nivel de componente (nuevo tipo de Atom, Molecule, etc.)
- AÃ±ades una nueva carpeta en `/src`
- Cambias la estructura del proyecto
- AÃ±ades nuevas convenciones o reglas

**Archivos a actualizar:**

- README especÃ­fico de la carpeta afectada
- ARCHITECTURE.md si afecta la arquitectura
- PROJECT_STRUCTURE.md si afecta la estructura

### NO actualizar documentaciÃ³n para:

- Componentes individuales rutinarios
- Cambios menores de estilos
- Fixes de bugs sin impacto arquitectÃ³nico

---

## ğŸš€ ANTES DE COMPLETAR UNA TAREA

### Checklist final OBLIGATORIO:

1. âœ… El cÃ³digo compila sin errores de TypeScript
2. âœ… No hay warnings de linter
3. âœ… El formato es consistente (comillas dobles, punto y coma, etc.)
4. âœ… Los imports usan alias correctamente
5. âœ… No hay cÃ³digo duplicado
6. âœ… Los nombres siguen las convenciones
7. âœ… La estructura de archivos es correcta
8. âœ… Se respeta Atomic Design
9. âœ… El cÃ³digo es limpio y legible
10. âœ… No se crearon archivos innecesarios

---

## âš ï¸ CASOS ESPECIALES

### Si el usuario pide algo que rompe estas reglas:

1. **Informar al usuario** sobre la regla que se romperÃ­a
2. **Sugerir alternativa** que respete las reglas
3. **Solo si insiste**, hacer lo solicitado pero documentar la excepciÃ³n

### Si encuentras cÃ³digo existente que no sigue estas reglas:

1. **NO cambiar** todo el cÃ³digo inmediatamente
2. **Aplicar las reglas** solo al cÃ³digo nuevo o modificado
3. **Mantener consistencia** con el cÃ³digo circundante
4. **Sugerir refactor** si es apropiado

---

## ğŸ“Š PRIORIDADES

En orden de importancia:

1. **Funcionalidad correcta** - El cÃ³digo debe funcionar
2. **TypeScript sin errores** - Debe compilar
3. **Arquitectura Atomic Design** - Respetar la estructura
4. **Convenciones de cÃ³digo** - Formato y estilo
5. **Performance** - OptimizaciÃ³n cuando sea necesaria
6. **DocumentaciÃ³n** - Mantener docs actualizados

---

## ğŸ¯ RESUMEN EJECUTIVO

**Antes de CUALQUIER acciÃ³n:**

1. âœ… Leer estas reglas
2. âœ… Verificar que entiendes la tarea
3. âœ… Planificar respetando Atomic Design
4. âœ… Verificar que no duplicas cÃ³digo
5. âœ… Usar alias de importaciÃ³n
6. âœ… Mantener formato consistente
7. âœ… Verificar antes de completar

**Recuerda:**

- ğŸ—ï¸ Atomic Design es OBLIGATORIO
- ğŸ“ Estructura de carpetas es SAGRADA
- ğŸ’» TypeScript strict es REQUERIDO
- ğŸ¨ Tailwind CSS es el ESTÃNDAR
- ğŸ“ Formato consistente es ESENCIAL
- ğŸš« DuplicaciÃ³n de cÃ³digo estÃ¡ PROHIBIDA

---

**Ãšltima actualizaciÃ³n:** Octubre 2025
**VersiÃ³n:** 1.0.0

---

## ğŸ¤– PARA CURSOR AI

Este archivo DEBE ser consultado ANTES de:

- Crear cualquier archivo nuevo
- Modificar cÃ³digo existente
- Instalar dependencias
- Cambiar estructura de proyecto
- Responder a cualquier prompt del usuario

**NO proceder con una tarea si:**

- Rompe las reglas de Atomic Design
- Duplica cÃ³digo existente
- No sigue las convenciones de nomenclatura
- Introduce errores de TypeScript
- Crea archivos fuera de la estructura establecida

**SIEMPRE pregunta al usuario si:**

- La tarea requiere romper alguna regla
- No estÃ¡ claro el nivel de Atomic Design apropiado
- Se necesita instalar una nueva dependencia
- El cambio afecta mÃºltiples archivos
